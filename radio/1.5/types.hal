/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.radio@1.5;

import @1.1::EutranBands;
import @1.1::GeranBands;
import @1.1::RadioAccessNetworks;
import @1.1::RadioAccessSpecifier;
import @1.1::ScanType;
import @1.1::UtranBands;
import @1.2::NetworkScanRequest;
import @1.4::AccessNetwork;
import @1.4::ApnTypes;
import @1.4::DataProfileInfo;

/**
 * Defining signal strength type.
 */
enum SignalMeasurementType : int32_t {
    /**
     * Received Signal Strength Indication.
     * Range: -113 dBm and -51 dBm
     * Used RAN: GERAN, CDMA2000
     * Reference: 3GPP TS 27.007 section 8.5.
     */
    RSSI = 1,
    /**
     * Received Signal Code Power.
     * Range: -120 dBm to -25 dBm;
     * Used RAN: UTRAN
     * Reference: 3GPP TS 25.123, section 9.1.1.1
     */
    RSCP = 2,
    /**
     * Reference Signal Received Power.
     * Range: -140 dBm to -44 dBm;
     * Used RAN: EUTRAN
     * Reference: 3GPP TS 36.133 9.1.4
     */
    RSRP = 3,
    /**
     * Reference Signal Received Quality
     * Range: -20 dB to -3 dB;
     * Used RAN: EUTRAN
     * Reference: 3GPP TS 36.133 9.1.7
     */
    RSRQ = 4,
    /**
     * Reference Signal Signal to Noise Ratio
     * Range: -20 dB to 30 dB;
     * Used RAN: EUTRAN
     * Note: this field is optional; how to support it can be decided by the
     * corresponding vendor. Though the response code is not enforced,
     * vendor's implementation must ensure this interface not crashing.
     */
    RSSNR = 5,
    /**
     * 5G SS reference signal received power.
     * Range: -140 dBm to -44 dBm.
     * Used RAN: NGRAN
     * Reference: 3GPP TS 38.215.
     */
    SSRSRP = 6,
    /**
     * 5G SS reference signal received quality.
     * Range: -20 dB to -3 dB.
     * Used RAN: NGRAN
     * Reference: 3GPP TS 38.215.
     */
    SSRSRQ = 7,
    /**
     * 5G SS signal-to-noise and interference ratio.
     * Range: -23 dB to 40 dB
     * Used RAN: NGRAN
     * Reference: 3GPP TS 38.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
     */
    SSSINR = 8,
};

/**
 * Contains the threshold values of each signal measurement type.
 */
struct SignalThresholdInfo {
    /** Signal Measurement Type */
    SignalMeasurementType signalMeasurement;

    /** A hysteresis time in milliseconds to prevent flapping. A value of 0 disables hysteresis */
    int32_t hysteresisMs;

    /**
     * An interval in dB defining the required magnitude change between reports.
     * hysteresisDb must be smaller than the smallest threshold delta.
     * An interval value of 0 disables hysteresis.
     */
    int32_t hysteresisDb;

    /**
     * List of threshold values.
     * Range and unit must reference specific @1.5::SignalMeasurementType.
     * The threshold values for which to apply criteria.
     * A vector size of 0 disables the use of thresholds for reporting.
     */
    vec<int32_t> thresholds;

    /**
     * Indicates whether the reporting criteria of the corresponding measurement is enabled
     * (isEnabled==true) or disabled (isEnabled==false).
     *
     * If enabled, modem must trigger the report based on the criteria.
     * If disabled, modem must not trigger the report based on the criteria.
     */
    bool isEnabled;
};

enum AccessNetwork : @1.4::AccessNetwork {
    /**
     *  Next-Generation Radio Access Network (NGRAN)
     */
    NGRAN = 6,
};

enum RadioAccessNetworks : @1.1::RadioAccessNetworks {
    NGRAN = 4,
};

/**
 * Overwritten from @1.1::RadioAccessSpecifier to add NGRAN and NgranBands
 */
struct RadioAccessSpecifier {
    /**
     * The type of network to scan.
     */
    RadioAccessNetworks radioAccessNetwork;

    /**
     * The frequency bands to scan.
     * Maximum length of the vector is 8.
     */
    safe_union Bands {
        /** Valid only if radioAccessNetwork = GERAN. */
        vec<GeranBands> geranBands;
        /** Valid only if radioAccessNetwork = UTRAN. */
        vec<UtranBands> utranBands;
        /** Valid only if radioAccessNetwork = EUTRAN. */
        vec<EutranBands> eutranBands;
        /** Valid only if radioAccessNetwork = NGRAN. */
        vec<NgranBands> ngranBands;
    } bands;

    /**
     * The radio channels to scan as defined in 3GPP TS 25.101 and 36.101.
     * Maximum length of the vector is 32.
     */
    vec<int32_t> channels;
};

enum NgranBands : int32_t {
    /** 3GPP TS 38.101-1, Table 5.2-1: FR1 bands */
    BAND_1 = 1,
    BAND_2 = 2,
    BAND_3 = 3,
    BAND_5 = 5,
    BAND_7 = 7,
    BAND_8 = 8,
    BAND_12 = 12,
    BAND_14 = 14,
    BAND_18 = 18,
    BAND_20 = 20,
    BAND_25 = 25,
    BAND_28 = 28,
    BAND_29 = 29,
    BAND_30 = 30,
    BAND_34 = 34,
    BAND_38 = 38,
    BAND_39 = 39,
    BAND_40 = 40,
    BAND_41 = 41,
    BAND_48 = 48,
    BAND_50 = 50,
    BAND_51 = 51,
    BAND_65 = 65,
    BAND_66 = 66,
    BAND_70 = 70,
    BAND_71 = 71,
    BAND_74 = 74,
    BAND_75 = 75,
    BAND_76 = 76,
    BAND_77 = 77,
    BAND_78 = 78,
    BAND_79 = 79,
    BAND_80 = 80,
    BAND_81 = 81,
    BAND_82 = 82,
    BAND_83 = 83,
    BAND_84 = 84,
    BAND_86 = 86,
    BAND_90 = 90,
    /** 3GPP TS 38.101-2, Table 5.2-1: FR2 bands */
    BAND_257 = 257,
    BAND_258 = 258,
    BAND_260 = 260,
    BAND_261 = 261,
};

/**
 * Overwritten from @1.2::NetworkScanRequest to update
 * RadioAccessSpecifier to 1.5 version
 */
struct NetworkScanRequest {
    ScanType type;

    /**
     * Time interval in seconds between the completion of one scan and the start of
     * a subsequent scan.
     * Implementations may ignore this field unless the 'type' is 'PERIODIC'.
     * Range: ScanIntervalRange:MIN to ScanIntervalRange:MAX
     */
    int32_t interval;

    /**
     * Networks with bands/channels to scan
     * Maximum length of the vector is RadioConst:RADIO_ACCESS_SPECIFIER_MAX_SIZE
     */
    vec<RadioAccessSpecifier> specifiers;

    /**
     * Maximum duration of the periodic search (in seconds).
     * If the search lasts maxSearchTime, it must be terminated.
     * Range: MaxSearchTimeRange:MIN to MaxSearchTimeRange:MAX
     */
    int32_t maxSearchTime;

    /**
     * Indicates whether the modem must report incremental results of the network scan
     * to the client.
     * FALSE – Incremental results must not be reported.
     * TRUE  – Incremental must be reported.
     */
    bool incrementalResults;

    /**
     * Indicates the periodicity with which the modem must report incremental results to
     * the client (in seconds).
     * Implementations may ignore this value if the incremental results are not requested.
     * This value must be less than or equal to maxSearchTime.
     * Range: IncrementalResultsPeriodicityRange:MIN to IncrementalResultsPeriodicityRange:MAX
     */
    int32_t incrementalResultsPeriodicity;

    /**
     * Describes the List of PLMN ids (MCC-MNC)
     * If any PLMN of this list is found, search must end at that point and results with all
     * PLMN found until that point should be sent as response.
     * If the list is not sent, search to be completed until end and all PLMNs found to be
     * reported.
     */
    vec<string> mccMncs;
};

enum ApnTypes : @1.4::ApnTypes {
    /**
     * APN type for XCAP
     * NOTE: Due to the addition of this new value, the value ALL defined in
     * 1.0::ApnTypes is deprecated and should not be used.
     */
    XCAP = 1 << 11,
};

/**
 * Extended from @1.4::DataProfileInfo to update ApnTypes to 1.5 version
 */
struct DataProfileInfo {
    @1.4::DataProfileInfo base;

    /** Supported APN types bitmap. See ApnTypes for the value of each bit. */
    bitfield<ApnTypes> supportedApnTypesBitmap;
};
