/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.radio@1.2;

import @1.0::CdmaSignalStrength;
import @1.0::CellIdentityCdma;
import @1.0::CellIdentityGsm;
import @1.0::CellIdentityLte;
import @1.0::CellIdentityWcdma;
import @1.0::CellInfoTdscdma;
import @1.0::CellInfoType;
import @1.0::EvdoSignalStrength;
import @1.0::GsmSignalStrength;
import @1.0::LteSignalStrength;
import @1.0::RadioConst;
import @1.0::TimeStampType;
import @1.0::WcdmaSignalStrength;
import @1.1::RadioAccessSpecifier;
import @1.0::RadioError;
import @1.1::ScanStatus;
import @1.1::ScanType;

enum RadioConst : @1.0::RadioConst {
    RADIO_ACCESS_SPEFICIER_MAX_SIZE = 8,
};

/**
 * values are in seconds
 */
enum ScanIntervalRange : int32_t {
    MIN = 5,
    MAX = 300,
};

/**
 * value are in seconds
 */
enum MaxSearchTimeRange : int32_t {
    MIN = 60,
    MAX = 3600,
};

/**
 * values are in seconds
 */
enum IncrementalResultsPeriodicityRange : int32_t {
    MIN = 1,
    MAX = 10,
};

struct NetworkScanRequest {
    ScanType type;

    /**
     * Time interval in seconds between periodic scans, only valid when type = PERIODIC
     * Range: ScanIntervalRange:MIN to ScanIntervalRange:MAX
     */
    int32_t interval;

    /**
     * Networks with bands/channels to scan
     * Maximum length of the vector is
     * RadioConst:RADIO_ACCESS_SPEFICIER_MAX_SIZE
     */
    vec<RadioAccessSpecifier> specifiers;

    /**
     * Maximum duration of the periodic search (in seconds).
     * Expected range for the input is [MaxSearchTimeRange:MIN - MaxSearchTimeRange:MAX]
     * If the search lasts maxSearchTime, it must be terminated.
     */
    int32_t maxSearchTime;

    /**
     * Indicates whether the modem must report incremental results of the network scan
     * to the client.
     * FALSE – Incremental results must not be reported.
     * TRUE  – Incremental must be reported.
     */
    bool incrementalResults;

    /**
     * Indicates the periodicity with which the modem must report incremental results to
     * the client (in seconds).
     * Expected range for the input is
     * [IncrementalResultsPeriodicityRange:MIN - IncrementalResultsPeriodicityRange:MAX]
     * This value must be less than or equal to maxSearchTime.
     */
    int32_t incrementalResultsPeriodicity;

    /**
     * Describes the List of PLMN ids (MCC-MNC)
     * If any PLMN of this list is found, search must end at that point and results with all
     * PLMN found until that point should be sent as response.
     * If the list is not sent, search to be completed until end and all PLMNs found to be
     * reported.
     */
    vec<string> mccMncs;
};

struct NetworkScanResult {
    /**
     * The status of the scan.
     */
    ScanStatus status;

    /**
     * The error code of the incremental result.
     */
    RadioError error;

    /**
     * List of network information as CellInfo.
     */
    vec<CellInfo> networkInfos;
};

struct CellIdentityOperatorNames {
    /**
     * Long alpha Operator Name String or Enhanced Operator Name String.
     */
    string alphaLong;

    /**
     * Short alpha Operator Name String or Enhanced Operator Name String
     */
    string alphaShort;
};

struct CellIdentityCdma {
    @1.0::CellIdentityCdma base;
    CellIdentityOperatorNames operatorNames;
};

struct CellIdentityGsm {
    @1.0::CellIdentityGsm base;
    CellIdentityOperatorNames operatorNames;
};

struct CellIdentityLte {
    @1.0::CellIdentityLte base;
    CellIdentityOperatorNames operatorNames;
};

struct CellIdentityWcdma {
    @1.0::CellIdentityWcdma base;
    CellIdentityOperatorNames operatorNames;
};

struct CellInfoGsm {
    CellIdentityGsm cellIdentityGsm;
    GsmSignalStrength signalStrengthGsm;
};

struct CellInfoWcdma {
    CellIdentityWcdma cellIdentityWcdma;
    WcdmaSignalStrength signalStrengthWcdma;
};

struct CellInfoCdma {
    CellIdentityCdma cellIdentityCdma;
    CdmaSignalStrength signalStrengthCdma;
    EvdoSignalStrength signalStrengthEvdo;
};

struct CellInfoLte {
    CellIdentityLte cellIdentityLte;
    LteSignalStrength signalStrengthLte;
};

struct CellInfo {
    /**
     * Cell type for selecting from union CellInfo.
     */
    CellInfoType cellInfoType;
    /*
     * True if this cell is registered false if not registered.
     */
    bool registered;
    /*
     * Type of time stamp represented by timeStamp.
     */
    TimeStampType timeStampType;
    /*
     * Time in nanos as returned by ril_nano_time.
     */
    uint64_t timeStamp;
    /*
     * Only one of the below vectors must be of size 1 based on the CellInfoType and others must be
     * of size 0.
     */
    vec<CellInfoGsm> gsm;
    /*
     * Valid only if type = cdma and size = 1 else must be empty.
     */
    vec<CellInfoCdma> cdma;
    /*
     * Valid only if type = lte and size = 1 else must be empty.
     */
    vec<CellInfoLte> lte;
    /*
     * Valid only if type = wcdma and size = 1 else must be empty.
     */
    vec<CellInfoWcdma> wcdma;
    /*
     * Valid only if type = tdscdma and size = 1 else must be empty.
     */
    vec<CellInfoTdscdma> tdscdma;
};